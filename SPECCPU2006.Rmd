---
title: "Understanding Trends of SPEC CPU 2006"
author: "Winston"
date: "September 26, 2014"
output: 
html_document:
    keep_md: true
---


###Synopisis

This is a quick look at trends in CPU performance based on the set of published SPECCPU2006 benchmark. The results are pulled directly from those published on the [SPEC.org](http://spec.org/cpu2006/results/) website, where you can read more about the benchmark and data collection.

CINT2006rate and CFP2006rate, studied here, measure important characteristics of computer performance and are widely followed benchmarks with a long history.


In the last few years it seems both MHz and core counts of processors have been increasing. 
The question addressed here is "whic factors have contributed most to increases in CPU performance over time?"   
The approach is to look at the causes of performance increases (namely core count and frequency) and then examine 1. whether they are correlated to performance increases, and then 2. their behavior over time.   

The main conclusion is that core count and CPU frequency contribute to performance gains since 2006, with increases in core count playing the larger role. 


###Data Processing

The program relies on web download for data. It checks for the existence of SPECCPU2006.csv on the local drive.
If the file is not found, the program downloads the data to teh local drive and then reads it into memory. (the file is too big for GitHub).  
  
The file contains about 30,000 observations.  
The data as downloaded are already very clean. The only cleaning modifications are:  
- date columns translated to _R_ data format.   
- eliminate some zero Result values  
- filter for the rate measurements  

```{r "get_data", echo=TRUE, cache=TRUE}


## data are located at the SPEC website
url <- "http://spec.org/cgi-bin/osgresults?conf=cpu2006;op=dump;format=csvdump"
destfile <- "SPECCPU2006.csv"

## check if the data are stored locally, and if not download
if(!file.exists(destfile)) download.file(url, destfile)

##read the data as a .csv file
SPECdata <- read.csv(destfile)
## the structure of the raw data
str(SPECdata)

```

```{r "data_clean_dates", cache=TRUE}

##convert data to dates in R format
        ##The incoming data are in a mmm-YYYY format. 
        ##I had to append a day to the date data (which I chose as the 15th (arbitrarily))
        ## All date data are scrubbed though not all are necessarily used.

        ## HW.Avail data
        SPECdata$HW.Avail <- as.character(SPECdata$HW.Avail)
        SPECdata$HW.Avail <- paste0("15-", SPECdata$HW.Avail)
        SPECdata$HW.Avail<- as.Date(SPECdata$HW.Avail, format="%d-%b-%Y")

        ## SW.Avail date
        SPECdata$SW.Avail <- as.character(SPECdata$SW.Avail)
        SPECdata$SW.Avail <- paste0("15-", SPECdata$SW.Avail)
        SPECdata$SW.Avail<- as.Date(SPECdata$SW.Avail, format="%d-%b-%Y")

        ## Test Date
        SPECdata$Test.Date <- as.character(SPECdata$Test.Date)
        SPECdata$Test.Date <- paste0("15-", SPECdata$Test.Date)
        SPECdata$Test.Date<- as.Date(SPECdata$Test.Date, format="%d-%b-%Y")

        ## Publication date
        SPECdata$Published <- as.character(SPECdata$Published)
        SPECdata$Published <- paste0("15-", SPECdata$Published)
        SPECdata$Published<- as.Date(SPECdata$Published, format="%d-%b-%Y")

```

```{r "data_clean2_Values"}

##clean up results 
        ## Some spurious zero values need to be eliminated.
        SPECdata<-SPECdata[SPECdata$Result>3,]



        ##Select only the RATE version of the benchmarks
        SPECdata<-SPECdata[as.character(SPECdata$Benchmark)=="CFP2006rate"|as.character(SPECdata$Benchmark)=="CINT2006rate",]


```


Here is a first look at some of the data.  

```{r "expository_plot", echo=TRUE, cache=FALSE, fig.align='center'}

#Plot Data as function of date by various facets

        library(ggplot2)
        ##reduce chip count to four or lower
        SPECdataX<-SPECdata[SPECdata$X..Chips.< 5,]

        ## create plot of results versus date
        P1 <- ggplot(SPECdataX, aes(x=HW.Avail, y=Result))+geom_point(shape=1)
        P1 <- P1 + scale_y_log10()
        P1<- P1+ geom_point(aes(colour = factor(X..Cores.Per.Chip.)))
        

print(P1)



```

To simplify the plot this data has been filtered for systems with four chips and fewer and the data factored for cores per chip.  
Note the log scale which ranges over a factor of 100. Judging from this data computing performance has increased between a factor of ten and one hundred since 2006, when the benchmark was first introduced.  Based on a visual analysis core count seems to play a role in the performance increase, but other factors may as well. For instance processor frequency has long been associated with performance gains and has an obvious and direct correlation to processing speed. 
 
###Results

####Role of Core Count for Intel Xeon and Core processors

Here we look at Intel Xeon (server) and Core (personal computer) microprocessors individually. Both processors share a common processing core. To keep comparisons unambiguous we look at only systems with single chips in them, since multiple chips confound the analysis. The graph below shows clearly the dependency of performance on core count in each family. 

```{r "Intel_Core_and_Xeon", echo=TRUE,fig.width=8,fig.align='center' }

##Define ComputerType_x function to reduce data based on substring
        
        ##name_string is the string used to catergorize results (e.g. "Core")
        ##search string is what is used to select elements for the category
        ##Output is the data aggregation file. Note it should be set to NULL prior to running this for the first time.
        ##input is the raw data file
        ##The Outputfile add a column to the input data with the output 

        ComputerType_x <- function(name_string, search_string, output=SPECdata_x, input=SPECdata) { 
                temp <- input[grepl(search_string, input$Processor., ignore.case=TRUE), ]
                names <- rep(name_string, dim(temp)[1])
                temp<- cbind (names, temp)
                rbind(temp, output)
                }

        ##take only single chip systems
        SPECdataReduce<-SPECdata[SPECdata$X..Chips.==1,]
        ##initialize data frame
        SPECdata_x<-NULL

        SPECdata_x<-ComputerType_x("Intel Core", "core", input=SPECdataReduce)
        SPECdata_x<-ComputerType_x("Intel Xeon", "xeon", input=SPECdataReduce)

        #plot
        P1 <- ggplot(SPECdata_x, aes(x=HW.Avail, y=Result))+geom_point(shape=1)
        P1 <- P1 + scale_y_log10()
        P1<- P1+ geom_point(aes(colour = factor(X..Cores.Per.Chip.)))
        P1<- P1 + facet_grid(. ~ names)
        P1<-P1+xlab("Date")+ylab("SPEC CPU Result")+ggtitle("SPEC CPU 2006 rate vs. processor family")


print(P1)
```

Clearly the results for Xeon and Core are comparable, though the Xeon product family has higher core count and thus extends to higher performance


####The role of core count on Xeon Performance

We can get a looking at the role core count plays by looking at a trend of the benchmarks as a function of core count directly. In the below graph the integer and floating point benchmarks are shown based on core count. The upward trend is unmistakable. The apparent "roll-off" of the curve with core count is an artefact of the way the data are analyzed, i.e. the horizontal axis is linear and the vertical axis is logarithmic.

```{r "Intel_Core_CoreCount", echo=TRUE,fig.width=9,fig.align='center' }

        ##take only single chip systems
        SPECdataReduce<-SPECdata[SPECdata$X..Chips.==1,]
        ##initialize results data.frame
        SPECdata_x<-NULL
        ##select Xeon processors
        SPECdata_x<-ComputerType_x("Intel Xeon", "xeon", input=SPECdataReduce)
        ##create plot of cores and results
        P1 <- ggplot(SPECdata_x, aes(x=factor(X..Cores.Per.Chip.), y=Result))
        P1<-P1+ coord_cartesian(ylim = c(10, 1000)) 
        P1 <- P1 + scale_y_log10(breaks=c(10,50, 100,500,1000))
        P1<- P1+ geom_boxplot(aes(fill=Benchmark))
        P1<-P1+xlab("Cores")+ylab("SPEC CPU Result")+ggtitle("SPEC CPU 2006 rate vs. core count\nfor Intel Xeon")

print(P1)
```

As we expect, the data show that as core count increases, so does performance. But are core counts increasing over time?


####Trends of Number of Cores 

```{r "Intel_CoreCount_TrendX", echo=TRUE,fig.width=5,fig.align='center' }

        ##Reduce data to single chip and and CINT2006rate

        SPECdataReduce<-SPECdata[SPECdata$X..Chips.==1,]
        SPECdataReduce<-SPECdataReduce[as.character(SPECdataReduce$Benchmark)=="CINT2006rate",]
        ##clear data 
        SPECdata_x<-NULL

        SPECdata_x<-ComputerType_x("Intel Xeon", "xeon", input=SPECdataReduce)

        dim(SPECdata_x)

        P1 <- ggplot(SPECdata_x, aes(x=HW.Avail,y=X..Cores.Per.Chip. ))
        P1 <- P1 + scale_y_log10()
        P1<- P1+ geom_point(shape=1)
        P1<-P1+xlab("Cores Per Chip")+ylab("Number of Cores")+ggtitle("Cores vs. Date\nfor single socket Xeon")

print(P1)

```

A clear upward trend in the number of cores is evident. Note that core number is plotted on a logarithmic scale. Thus, cores contribute to increased performance, and the number of cores is increasing in a roughly exponential manner with time, thus the observation that performance increases with time is correlates with the obersation that performance is increasing.

####The role of MHz

We can also look at the effect of processor speed (MHz) on the benchmark. The tie between MHz and performance is intuitively obvious. We can demonstrate it easily by looking at the data. 

To simplify the picture we'lll look at only two and four core parts. In addition, we'll only look at the Integer benchmark CINT2006rate though similar conclusions hold for CFP2006rate.


```{r "Intel_Core_MHz", echo=TRUE,fig.width=9,fig.align='center' }

        ##keep single chip systems with four or fewer processors and only the INT benchmark
        SPECdataReduce<-SPECdata[SPECdata$X..Chips.==1,]
        SPECdataReduce<-SPECdataReduce[SPECdataReduce$X..Cores.Per.Chip.<5,]
        SPECdataReduce<-SPECdataReduce[as.character(SPECdataReduce$Benchmark)=="CINT2006rate",]

        ##clear the results data frame
        SPECdata_x<-NULL
        ##select only core processors
        SPECdata_x<-ComputerType_x("Intel Core", "core", input=SPECdataReduce)
        ##cleate plot of Results v. MHz
        P1 <- ggplot(SPECdata_x, aes(x=Processor.MHz, y=Result))
        P1<-P1+ coord_cartesian(ylim = c(10, 1000)) 
        P1 <- P1 + scale_y_log10(breaks=c(10,50, 100,500,1000))
        P1<- P1+ geom_point(aes(colour = factor(X..Cores.Per.Chip.)))
        P1<-P1+xlab("MHz")+ylab("SPECint Result")+ggtitle("CINT2006rate vs. MHz\nfor 1 and 2 threads per core")
        P1 <- P1 + facet_grid(.~X..Threads.Per.Core)
        P1<- P1 + theme(axis.text.x = element_text(angle = 0))
    
print(P1)


str(SPECdataReduce)
```

The data show a clear relationship between speed and performance, as expected. 
  
  
The data are also factored by the number of threads per core. It's interesting to note that the two thread per core two core parts have performance nearly equal to the four core parts with one thread per core, as expected. Although hyperthreading has an important impact on the performance benchmark, it's impact is apparently reduced for higher core count. 



####Trend of MHz 

With the relationship of MHz to performance established, the question is have MHz increased with time and do they play a strong role in the observed increase in performance.   

  
  
Here is a graph of MHZ for two core parts over time. The speed of the processors has increased from about 2500 to 3500 MHz, but in what appears to be a _linear_ manner. Thus, while MHz have played a role in increased performance, their contribution is linear and not exponential.

```{r "Intel_MHz_TrendX", echo=TRUE,fig.width=9,fig.align='center' }

        ##Reduce data to two cores 

        SPECdataReduce<-SPECdata[SPECdata$X..Chips.==1,]
        SPECdataReduce<-SPECdataReduce[SPECdataReduce$X..Cores.Per.Chip.==2,]
        SPECdataReduce<-SPECdataReduce[as.character(SPECdataReduce$Benchmark)=="CINT2006rate",]

        ##CLEAR RESULTS MATRIX
        SPECdata_x<-NULL
        ## select only core processors
        SPECdata_x<-ComputerType_x("Intel Core", "core", input=SPECdataReduce)
        ##plot MHz versus time
        P1 <- ggplot(SPECdata_x, aes(x=HW.Avail,y=Processor.MHz ))
        P1 <- P1 + stat_smooth(method="lm")
        P1<- P1+ geom_point()
        P1<-P1+xlab("Date")+ylab("MHz")+ggtitle("MHz vs. Date\nfor single thread two core parts")

print(P1)

```

Thus while MHz are increasing over time, their increase is much smaller than would account for the gain in performance observed. 

###Conclusions

Published performance data show an increase of roughly a factor of ten in the performance (computing speed) of microprocessors in the last eight years.  

A dominant contributor to the increase in capability has been the trend of increasing core count with core count being correlated to processor speed and core count has been increasing roughly exponentially with time.  

An additonal contribution to the increase in MHz, which also correlate to processor speed. But this contribution is not as important as core count. 